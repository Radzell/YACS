// Generated by CoffeeScript 1.3.3
(function() {

  describe('getCookie', function() {
    it('should extract value from cookie string', function() {
      var cookie;
      cookie = 'foo=bar;name=joe;rofl=coptor';
      expect(getCookie('foo', cookie)).toEqual('bar');
      expect(getCookie('name', cookie)).toEqual('joe');
      return expect(getCookie('rofl', cookie)).toEqual('coptor');
    });
    return it('should return null if no key exists in cookie string', function() {
      return expect(getCookie('foo', '')).toBeNull();
    });
  });

  describe('product', function() {
    it('should return an array with one empty array with no args', function() {
      return expect(product()).toEqual([[]]);
    });
    it('should return an array with original array of possibilities', function() {
      return expect(product([1, 2, 3])).toEqual([[1], [2], [3]]);
    });
    return it('should create product with multiple arrays', function() {
      return expect(product([1, 2, 3], [4, 5])).toEqual([[1, 4], [1, 5], [2, 4], [2, 5], [3, 4], [3, 5]]);
    });
  });

  describe('iterate', function() {
    it('should loop over items asynchronously', function() {
      runs(function() {
        this.eachfn = jasmine.createSpy().andCallFake(function(item, index) {
          var _ref;
          if ((_ref = this.i) == null) {
            this.i = 5;
          }
          expect([index, item]).toEqual([this.i - 5, this.i]);
          return this.i++;
        });
        this.endfn = jasmine.createSpy().andCallFake(function() {
          return expect(this.i).toEqual(10);
        });
        return iterate([5, 6, 7, 8, 9], {
          delay: 1,
          each: this.eachfn,
          end: this.endfn
        });
      });
      waits(10);
      return runs(function() {
        expect(this.eachfn.callCount).toEqual(5);
        return expect(this.endfn).toHaveBeenCalled();
      });
    });
    return it('should be cancellable', function() {
      runs(function() {
        var job;
        this.end = jasmine.createSpy();
        job = iterate([0, 1, 2, 3, 4], {
          delay: 1,
          each: jasmine.createSpy(),
          end: this.end
        });
        return job.abort();
      });
      waits(10);
      return runs(function() {
        return expect(this.end.callCount).toEqual(0);
      });
    });
  });

  describe('pushUnique', function() {
    it('inserts item if it does not exist in the array and return true', function() {
      var a;
      a = [1, 2, 3];
      expect(pushUnique(a, 4)).toBeTruthy();
      return expect(a).toEqual([1, 2, 3, 4]);
    });
    return it('does nothing if the item already exists in the array and return false', function() {
      var a;
      a = [1, 2, 3];
      expect(pushUnique(a, 2)).toBeFalsy();
      return expect(a).toEqual([1, 2, 3]);
    });
  });

  describe('format', function() {
    it('does nothing to format string only', function() {
      return expect(format('foo {{ 0 }}')).toEqual('foo {{ 0 }}');
    });
    it('formats based on positional arguments', function() {
      return expect(format('foo {{ 0 }} {{ 1 }}', 'bar', 'cake')).toEqual('foo bar cake');
    });
    it('formats even with undefined values', function() {
      return expect(format('foo {{ 0 }} {{ 1 }}', void 0, null)).toEqual('foo <undefined> <null>');
    });
    return it('formats based on object hash', function() {
      return expect(format('{{ hello }} {{ world }}', {
        hello: 'goodbye',
        world: 'everyone'
      })).toEqual('goodbye everyone');
    });
  });

  describe('hash_by_attr', function() {
    it('can flatten array of objects to an object', function() {
      var items, result;
      items = [
        {
          name: 'bob'
        }, {
          name: 'jane'
        }
      ];
      result = hash_by_attr(items, 'name', {
        flat: true
      });
      return expect(result).toEqual({
        bob: {
          name: 'bob'
        },
        jane: {
          name: 'jane'
        }
      });
    });
    it('can categorize array of objects in to a hash', function() {
      var items, result;
      items = [
        {
          name: 'bob',
          id: 1
        }, {
          name: 'jane',
          id: 2
        }, {
          name: 'bob',
          id: 3
        }
      ];
      result = hash_by_attr(items, 'name');
      return expect(result).toEqual({
        bob: [
          {
            name: 'bob',
            id: 1
          }, {
            name: 'bob',
            id: 3
          }
        ],
        jane: [
          {
            name: 'jane',
            id: 2
          }
        ]
      });
    });
    return it('can use functions instead of keys', function() {
      var items, result;
      items = [
        {
          name: 'bob',
          id: 1
        }, {
          name: 'jane',
          id: 2
        }, {
          name: 'bob',
          id: 3
        }
      ];
      result = hash_by_attr(items, (function(o) {
        return o.name;
      }), {
        value: function(o) {
          return o.id;
        }
      });
      return expect(result).toEqual({
        bob: [1, 3],
        jane: [2]
      });
    });
  });

  describe('barrier', function() {
    it('invokes callback after number of invocations', function() {
      var b, spy;
      spy = jasmine.createSpy();
      b = barrier(3, spy);
      b();
      b();
      expect(spy.callCount).toEqual(0);
      b();
      return expect(spy.callCount).toEqual(1);
    });
    return it('ignores further invocations', function() {
      var b, i, spy, _i;
      spy = jasmine.createSpy();
      b = barrier(1, spy);
      for (i = _i = 0; _i < 50; i = ++_i) {
        b();
      }
      return expect(spy.callCount).toEqual(1);
    });
  });

  describe('array_of_ints', function() {
    it('converts a sequence set of numbers into an array', function() {
      var items;
      items = array_of_ints('1, 2,3, 04');
      return expect(items).toEqual([1, 2, 3, 4]);
    });
    return it('returns empty array for empty string', function() {
      return expect(array_of_ints('')).toEqual([]);
    });
  });

}).call(this);
