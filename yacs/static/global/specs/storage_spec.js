// Generated by CoffeeScript 1.3.1
(function() {

  describe('storage', function() {
    var storage;
    storage = null;
    beforeEach(function() {
      return storage = {
        setItem: jasmine.createSpy(),
        getItem: jasmine.createSpy().andReturn('1'),
        clear: jasmine.createSpy()
      };
    });
    it('should store a key value pairs', function() {
      var s;
      s = new Storage({
        store: storage
      });
      s.set('foo', 1);
      expect(storage.setItem).toHaveBeenCalledWith('foo', '1');
      expect(s.get('foo')).toEqual(1);
      return expect(storage.getItem).toHaveBeenCalledWith('foo');
    });
    return it('should clear existing storage if version does not match', function() {
      var s;
      s = new Storage({
        store: storage,
        version: 2
      });
      s.version_check();
      expect(storage.getItem).toHaveBeenCalledWith('version');
      expect(storage.clear).toHaveBeenCalled();
      return expect(storage.setItem).toHaveBeenCalledWith('version', '2');
    });
  });

  describe('selection', function() {
    var storage;
    storage = null;
    beforeEach(function() {
      return storage = {
        version_check: jasmine.createSpy(),
        set: jasmine.createSpy(),
        get: jasmine.createSpy()
      };
    });
    it("should track changes to user's set of sections", function() {
      var loaded, s, saved;
      s = new Selection({
        storage: storage
      });
      saved = jasmine.createSpy();
      loaded = jasmine.createSpy();
      $(s).bind('saved', saved);
      s.add_section(1, 1);
      s.add_section(1, 1);
      s.add_section(1, 2);
      s.remove_section(1, 2);
      s.add_course(2, [3, 4]);
      expect(s.get_sections()).toEqual([1, 3, 4]);
      expect(s.get_courses()).toEqual([1, 2]);
      expect(s.has_courses()).toBeTruthy();
      s.clear();
      expect(s.get_sections()).toEqual([]);
      expect(s.get_courses()).toEqual([]);
      expect(s.has_courses()).toBeFalsy();
      expect(storage.version_check).toHaveBeenCalled();
      expect(storage.set).toHaveBeenCalled();
      return expect(saved).toHaveBeenCalled();
    });
    it('can copy itself', function() {
      var s1, s2;
      s1 = new Selection({
        storage: storage,
        data: {
          1: [1, 2],
          2: [3, 4]
        }
      });
      s2 = s1.copy();
      expect(s1.get_courses()).toEqual(s2.get_courses());
      return expect(s1.get_sections()).toEqual(s2.get_sections());
    });
    it('can undo last addition', function() {
      var s;
      s = new Selection({
        storage: storage
      });
      s.add_section(1, 1);
      s.add_section(1, 2);
      s.add_section(2, 3);
      expect(s.get_sections()).toEqual([1, 2, 3]);
      expect(s.get_courses()).toEqual([1, 2]);
      s.undo();
      expect(s.get_sections()).toEqual([1, 2]);
      expect(s.get_courses()).toEqual([1]);
      s.undo();
      expect(s.get_sections()).toEqual([1]);
      expect(s.get_courses()).toEqual([1]);
      s.undo();
      expect(s.get_sections()).toEqual([]);
      expect(s.get_courses()).toEqual([]);
      return s.undo();
    });
    return it('should be able to load from storage', function() {
      var loaded, s;
      storage = {
        version_check: jasmine.createSpy(),
        set: jasmine.createSpy(),
        get: jasmine.createSpy().andReturn({
          1: [2, 3],
          2: [4, 5]
        })
      };
      s = new Selection({
        storage: storage
      });
      loaded = jasmine.createSpy();
      $(s).bind('loaded', loaded);
      s.load();
      expect(loaded).toHaveBeenCalled();
      expect(storage.get).toHaveBeenCalledWith('selection');
      expect(s.get_sections()).toEqual([2, 3, 4, 5]);
      return expect(s.get_courses()).toEqual([1, 2]);
    });
  });

  describe('validator', function() {
    describe('internal helpers', function() {
      var v;
      v = null;
      beforeEach(function() {
        return v = new Validator();
      });
      describe('time_conflict', function() {
        it('should return true on conflicting times', function() {
          return expect(v._time_conflict({
            start: '09:00:00',
            end: '10:50:00',
            days_of_the_week: ['Monday']
          }, {
            start: '10:00:00',
            end: '11:50:00',
            days_of_the_week: ['Monday']
          })).toBeTruthy();
        });
        it('should return false on non-conflicting times', function() {
          return expect(v._time_conflict({
            start: '09:00:00',
            end: '10:50:00',
            days_of_the_week: ['Monday']
          }, {
            start: '11:00:00',
            end: '11:50:00',
            days_of_the_week: ['Monday']
          })).toBeFalsy();
        });
        return it('should return false on non-conflicting days of the week', function() {
          return expect(v._time_conflict({
            start: '09:00:00',
            end: '10:50:00',
            days_of_the_week: ['Monday']
          }, {
            start: '10:00:00',
            end: '11:50:00',
            days_of_the_week: ['Tuesday']
          })).toBeFalsy();
        });
      });
      describe('section_times_conflict', function() {
        it('should return true for sections that do conflict', function() {
          var result;
          result = v._section_times_conflict([
            {
              start: '09:00:00',
              end: '10:50:00',
              days_of_the_week: ['Monday']
            }
          ], [
            {
              start: '10:00:00',
              end: '11:50:00',
              days_of_the_week: ['Monday']
            }
          ]);
          return expect(result).toBeTruthy();
        });
        it('should return true for multiple sections that do conflict', function() {
          var result;
          result = v._section_times_conflict([
            {
              start: '09:00:00',
              end: '10:50:00',
              days_of_the_week: ['Monday']
            }, {
              start: '10:00:00',
              end: '10:50:00',
              days_of_the_week: ['Monday']
            }
          ], [
            {
              start: '10:00:00',
              end: '11:50:00',
              days_of_the_week: ['Monday']
            }
          ]);
          return expect(result).toBeTruthy();
        });
        return it('should return false if times do not conflict', function() {
          var result;
          result = v._section_times_conflict([
            {
              start: '14:00:00',
              end: '16:50:00',
              days_of_the_week: ['Monday']
            }, {
              start: '12:00:00',
              end: '13:50:00',
              days_of_the_week: ['Monday']
            }
          ], [
            {
              start: '10:00:00',
              end: '11:50:00',
              days_of_the_week: ['Monday']
            }
          ]);
          return expect(result).toBeFalsy();
        });
      });
      return describe('schedule_is_valid', function() {
        it('should return false if sections do conflict', function() {
          var result;
          result = v._schedule_is_valid({
            1: {
              start: '09:00:00',
              end: '10:50:00',
              days_of_the_week: ['Monday']
            },
            2: {
              start: '10:00:00',
              end: '11:50:00',
              days_of_the_week: ['Monday']
            }
          });
          return expect(result).toBeFalsy();
        });
        return it('should return true if sections do not conflict', function() {
          var result;
          result = v._schedule_is_valid({
            1: {
              start: '09:00:00',
              end: '10:50:00',
              days_of_the_week: ['Monday']
            },
            2: {
              start: '13:00:00',
              end: '14:50:00',
              days_of_the_week: ['Monday']
            }
          });
          return expect(result).toBeTruthy();
        });
      });
    });
    it('returns course id for invalid course', function() {
      var v;
      v = new Validator({
        data: {
          1: [1, 2, 5],
          2: [3]
        }
      }).set_conflicts(new API.Collection().add_array([
        new API.Model({
          id: 1,
          conflicts: [1, 2, 3]
        }), new API.Model({
          id: 2,
          conflicts: [1, 4]
        }), new API.Model({
          id: 3,
          conflicts: [1]
        }), new API.Model({
          id: 4,
          conflicts: [2]
        }), new API.Model({
          id: 5,
          conflicts: []
        })
      ]));
      expect(v.conflicts_with(6)).toBeNull();
      expect(v.conflicts_with(5)).toBeNull();
      expect(v.conflicts_with(3)).toEqual(1);
      return expect(v.conflicts_with(4)).toEqual(1);
    });
    return describe('detect cyclic conflicts', function() {
      describe('with simple conflicts', function() {
        var sections;
        sections = null;
        beforeEach(function() {
          return sections = new API.Collection().add_array([
            new API.Model({
              id: 1,
              section_times: [
                {
                  start: '10:00:00',
                  end: '11:00:00',
                  days_of_the_week: ['Monday']
                }, {
                  start: '12:00:00',
                  end: '14:00:00',
                  days_of_the_week: ['Monday']
                }
              ]
            }), new API.Model({
              id: 2,
              section_times: [
                {
                  start: '12:00:00',
                  end: '13:00:00',
                  days_of_the_week: ['Monday']
                }
              ]
            }), new API.Model({
              id: 3,
              section_times: [
                {
                  start: '10:00:00',
                  end: '11:00:00',
                  days_of_the_week: ['Monday']
                }
              ]
            })
          ]);
        });
        it('should validate if only one conflict', function() {
          var v;
          v = new Validator({
            data: {
              1: [1],
              2: [2]
            }
          }).set_sections(sections);
          return expect(v.is_valid()).toBeTruthy();
        });
        return it('should not validate if no possible schedules', function() {
          var v;
          v = new Validator().set_data({
            1: [1],
            2: [2],
            3: [3]
          }).set_sections(sections);
          return expect(v.is_valid()).toBeFalsy();
        });
      });
      it('should validate if different day of the week', function() {
        var sections, v;
        sections = new API.Collection().add_array([
          new API.Model({
            id: 1,
            section_times: [
              {
                start: '10:00:00',
                end: '11:00:00',
                days_of_the_week: ['Tuesday']
              }, {
                start: '12:00:00',
                end: '14:00:00',
                days_of_the_week: ['Tuesday']
              }
            ]
          }), new API.Model({
            id: 2,
            section_times: [
              {
                start: '12:00:00',
                end: '13:00:00',
                days_of_the_week: ['Monday']
              }
            ]
          }), new API.Model({
            id: 3,
            section_times: [
              {
                start: '10:00:00',
                end: '11:00:00',
                days_of_the_week: ['Monday']
              }
            ]
          })
        ]);
        v = new Validator().set_data({
          1: [1],
          2: [2],
          3: [3]
        }).set_sections(sections);
        return expect(v.is_valid()).toBeTruthy();
      });
      it('should validate if there are more free sections', function() {
        var sections, v;
        sections = new API.Collection().add_array([
          new API.Model({
            id: 1,
            section_times: [
              {
                start: '10:00:00',
                end: '11:00:00',
                days_of_the_week: ['Monday']
              }, {
                start: '12:00:00',
                end: '14:00:00',
                days_of_the_week: ['Monday']
              }
            ]
          }), new API.Model({
            id: 2,
            section_times: [
              {
                start: '15:00:00',
                end: '16:00:00',
                days_of_the_week: ['Tuesday']
              }
            ]
          }), new API.Model({
            id: 3,
            section_times: [
              {
                start: '12:00:00',
                end: '13:00:00',
                days_of_the_week: ['Monday']
              }
            ]
          }), new API.Model({
            id: 4,
            section_times: [
              {
                start: '10:00:00',
                end: '11:00:00',
                days_of_the_week: ['Monday']
              }
            ]
          })
        ]);
        v = new Validator().set_data({
          1: [1, 2],
          2: [3],
          3: [4]
        }).set_sections(sections);
        return expect(v.is_valid()).toBeTruthy();
      });
      return it('should return true on empty', function() {
        var v;
        v = new Validator().set_data();
        return expect(v.is_valid()).toBeTruthy();
      });
    });
  });

}).call(this);
