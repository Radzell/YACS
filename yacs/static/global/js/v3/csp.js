// Generated by CoffeeScript 1.3.1
(function() {
  var Problem, brute_force, product,
    __slice = [].slice;

  product = function() {
    var array, arrays, newarr, result, tmp, x, y, _i, _j, _k, _len, _len1, _len2;
    arrays = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    result = [[]];
    for (_i = 0, _len = arrays.length; _i < _len; _i++) {
      array = arrays[_i];
      tmp = [];
      for (_j = 0, _len1 = result.length; _j < _len1; _j++) {
        x = result[_j];
        for (_k = 0, _len2 = array.length; _k < _len2; _k++) {
          y = array[_k];
          newarr = x.slice(0);
          newarr.push(y);
          tmp.push(newarr);
        }
      }
      result = tmp;
    }
    return result;
  };

  brute_force = function(problem, options) {
    var domains, results, solution, solution_values, variables, _i, _len, _ref;
    options = $.extend({
      max_results: 0
    }, options);
    variables = problem.variables();
    domains = problem.domains();
    results = [];
    _ref = product.apply(null, domains);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      solution_values = _ref[_i];
      solution = problem.create_solution(solution_values);
      if (problem.satisfies(solution)) {
        results.push(solution);
      }
      if (options.max_results > 0 && options.max_results <= results.length) {
        return results;
      }
    }
    return results;
  };

  Problem = (function() {

    Problem.name = 'Problem';

    function Problem(options) {
      options = $.extend({}, options);
      this.space = $.extend({}, options.variables);
      this.constraints = options.constraints || [];
      this.solver = options.solver || brute_force;
      if (!this.is_valid()) {
        console.warn('Improperly defined Problem');
      }
    }

    Problem.prototype.is_valid = function() {
      var constraint, domain, _i, _j, _len, _len1, _ref, _ref1;
      _ref = this.domains();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        domain = _ref[_i];
        if ($.type(domain) !== 'array') {
          return false;
        }
      }
      _ref1 = this.constraints;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        constraint = _ref1[_j];
        if (!$.isFunction(constraint)) {
          return false;
        }
      }
      return true;
    };

    Problem.prototype.variables = function() {
      return Object.keys(this.space);
    };

    Problem.prototype.domains = function() {
      var x, _i, _len, _ref, _results;
      _ref = this.variables();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        x = _ref[_i];
        _results.push(this.space[x]);
      }
      return _results;
    };

    Problem.prototype.create_solution = function(values, variables) {
      var i, result, _i, _ref;
      if (variables == null) {
        variables = this.variables();
      }
      result = {};
      for (i = _i = 0, _ref = variables.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        result[variables[i]] = values[i];
      }
      return result;
    };

    Problem.prototype.satisfies = function(solution) {
      var c, _i, _len, _ref;
      if ($.type(solution) === 'array') {
        solution = this.create_solution(solution);
      }
      _ref = this.constraints;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        if (!c(solution)) {
          return false;
        }
      }
      return true;
    };

    return Problem;

  })();

  this.CSP = {
    Problem: Problem,
    bruteForce: brute_force,
    product: product
  };

}).call(this);
